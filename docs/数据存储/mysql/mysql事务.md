# mysql事务

## 1. 事务操作

### 开启/关闭自动提交

```sql
-- 查看自动提交
SHOW VARIABLES LIKE '%autocommit%'
-- 关闭自动提交，只针对当前的会话有效
SET autocommit = 0
```
### 使用事务

```sql
-- 开启事务
BEGIN;
-- 插入数据
INSERT tb_user VALUES ('张三', 22);
INSERT tb_user VALUES ('李四', 23);
-- 提交事务
COMMIT;
-- 回滚事务
ROLLBACK;
```

### 保存点

保存点就是可以回滚到指定的之前设置的保存点。当开启事务之后操作了很多`SQL`，可以设置个保存点。当再执行的`SQL`有问题不需要的时候就可以回滚到之前设置的保存点，不用把当前事务整个回滚掉。

```sql
-- 设置保存点
SAVEPOINT 保存点名称;
-- 回滚到指定保存点
ROLLBACK to 保存点名称;
-- 删除保存点
RELEASE SAVEPOINT 保存点名称;
```

### 查看隔离级别

```sql
-- 修改隔离级别
set session transaction isolation level 事务隔离级别;
-- 查看隔离级别
select @@transaction_isolation;
```

## 2. 事务并发性问题

对于同时运行多个事务，这些事务访问**数据库中相同的数据**时，没有没有采取必要的隔离机制，就会导致各种并发问题：
- 脏读：事务A读到了事务B已修改但尚未提交的数据，此时事务B回滚，A读取数据无效，不符合一致性。
- 不可重复读：事务A读到了事务B已提交的修改数据，不符合隔离性。
- 幻读：事务A读到了事务B提交的新增数据，不符合隔离性。

## 3. Mysql提供的4种隔离级别
| 隔离级别                         | 描述                                 |
| -------------------------------- | ------------------------------------ |
| 读未提交 READ UNCOMMITTED        | 存在脏读，不可重复读，幻读问题       |
| 读已提交 READ COMMITTED          | 可避免脏读，存在不可重复度，幻读问题 |
| 可重复读 REPEATABLE READ（默认） | 可避免脏读，不可重复读，存在幻读问题 |
| 可序列化 SERIALIZABLE            | 所有问题可避免，但性能低下           |

## 4. MVCC

指的就是在使用`READ COMMITTD` `REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的版本链的过程。可以使不同事务的读写、写读操作并发执行，从而提升系统性能。其主要是通过无锁的机制提升性能。

说说其是怎么实现的，首先要知道版本链，和`readview`。

### 版本链

首先要知道在`innodb`中有两个隐藏列，`trx_id(存放事务ID),roll_pointer(存放一个指向上一事务版本的指针)`![在这里插入图片描述](https://img-blog.csdnimg.cn/20210101213930600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

### readview

类似数组结构，主要用来记录当前活跃事务`ID`。结合版本链既可以判断某条记录是否可见。

在**读已提交级别**中怎么控制其他事务提交后数据可见。

首先有两个事务，`ID`分别为82，200。事务一查询所有数据时`readview`查询当前活跃事务然后保存了两个事务`ID[82，200]`后再判断第一条事务`ID = 200`在`readview`中，就代表是其他活跃事务没有提交的数据，所以就往下走，`ID = 82`是当前自己的事务可以查询，接着往下以此类推就可以查询出所有数据。事务一再次查询时（在查询之前事务二提交），**`readview`查询当前活跃事务**然后保存了一个事务`ID[82]`后再判断第一条事务`ID = 200`不在`readview`中表示该条数据可见。接着往下走，`ID = 82`是当前自己的事务可以查询，接着往下以此类推就可以查询出所有数据。

总结：每次读取数据前都生成一个`ReadView`

在**可重复读级别**中怎么控制其他事务提交后当前事务中对其他事务提交的数据不可见。

首先有两个事务，`ID`分别为82，200。事务一查询所有数据时`readview`查询当前活跃事务然后保存了两个事务`ID[82，200]`后再判断第一条事务`ID = 200`在`readview`中，就代表是其他活跃事务没有提交的数据，所以就往下走，`ID = 82`是当前自己的事务可以查询，接着往下以此类推就可以查询出所有数据。事务一再次查询时（在查询之前事务二提交），**此时`readview`继续使用第一次的`readview`**所以判断第一条事务`ID = 200`在`readview`中，就代表是其他活跃事务没有提交的数据，所以就往下走，`ID = 82`是当前自己的事务可以查询，接着往下以此类推就可以查询出所有数据。

总结：在第一次读取数据时生成一个`ReadView`，后边再次查询不在生成`ReadView`。