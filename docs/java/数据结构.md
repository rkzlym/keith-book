# 数据结构

## 时间/空间复杂度

### 1. 时间复杂度

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216220144701.png)

常对幂指阶：常数级<对数级<幂数级<指数级<阶乘

结论1：顺序执行的代码只影响常数项，可以忽略

结论2：只需挑循环中的一个基本操作分析它的执行次数与n的关系即可

练习：计算时间复杂度

```java
void loveYou(int n){	// n为问题规模
    int i = 1;
    while(i <= n){
        i = i * 2;
        printf("I love you %d\n", i);
    }
}
```

设总循环的次数为x，则由循环条件可知，循环结束刚好满足2^x > n

x = log₂n + 1

T(n) = O(log₂n)

### 2. 空间复杂度

```java
// S(n) = O(1)
void test(){
    int i;
}
```

```java
// S(n) = O(n)
void test(int n){
	int arr[n];
    int i;
}
```

```java
// S(n) = O(n²)
void test(int n){
    int arr1[n][n];
	int arr2[n];
    int i;
}
```

递归调用空间复杂度：空间复杂度 = 递归调用的深度

## 线性/非线性结构

**线性结构**：元素之间存在一对一的线性关系，常见的有：数组、队列、链表、栈

线性结构有两种不同的存储结构：

- 顺序表：存储的元素是连续的

- 链表：存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息

**非线性结构**：二维数组，多维数组，广义表，树结构，图结构

## 单链表

```java
static class Node<E> {
    E element;
    Node<E> next;

    Node(E element, Node<E> next) {
        this.element = element;
        this.next = next;
    }

    @Override
    public String toString() {
        return element + "";
    }
}

static class LinkedList<E>{
    private Node<E> head;

    void add(E e){
        if (head == null){
            head = new Node<>(e, null);
            return;
        }
        Node<E> tmp = head;
        while (tmp.next != null) {
            tmp = tmp.next;
        }
        tmp.next = new Node<>(e, null);
    }

    void add(int index, E e){
        if (index <= 0){
            Node<E> tmp = head;
            head = new Node<>(e, tmp);
        } else {
            Node<E> next = node(index);
            Node<E> prev = node(index - 1);
            prev.next = new Node<>(e, next);
        }
    }

    void remove(int index){
        if (index <= 0){
            head = head.next;
        } else {
            Node<E> prev = node(index - 1);
            prev.next = node(index + 1);
        }
    }

    Node<E> node(int index) {
        if (index < 0)
            index = 0;
        Node<E> tmp = head;
        for (int i = 0; i < index; i++){
            if (tmp == null)
                break;
            tmp = tmp.next;
        }
        return tmp;
    }

    void showAll(){
        Node<E> tmp = head;
        while (tmp != null){
            System.out.print((tmp) + "\t");
            tmp = tmp.next;
        }
    }
}

public static void main(String[] args) {
    LinkedList<Object> list = new LinkedList<>();
    list.add("aaa");
    list.add("bbb");
    list.add("ccc");
    list.add(0, "ddd");
    list.add(1, "eee");
    list.remove(1);
    list.showAll();
}
```

## 环形队列

> 队列是一个有序列表，可以用数组或链表实现，遵循先进先出原则

数组实现环形队列：尾索引的下一个为头索引时表示队列满

```java
class CircleQueue{
    private int maxSize;
    private int front;
    private int rear;
    private int arr[];

    public CircleQueue(int maxSize){
        this.maxSize = maxSize;
        arr = new int[maxSize];
    }

    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }

    public boolean isEmpty(){
        return rear == front;
    }

    public void add(int n){
        if (isFull())
            throw new UnsupportedOperationException("cannot add element to full queue");
        arr[rear] = n;
        rear = (rear + 1) % maxSize;
    }

    public int poll(){
        if (isEmpty())
            throw new UnsupportedOperationException("cannot poll element to empty queue");
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    public void showAll(){
        for (int i = front; i < front + size(); i++){
            System.out.printf("arr[%d] = %d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    public int size() {
        return (rear - front + maxSize) % maxSize;
    }
}

public static void main(String[] args) {
    CircleQueue queue = new CircleQueue(4);
    queue.add(1);
    queue.add(2);
    queue.add(3);
    queue.showAll();
    System.out.println();
    queue.poll();
    queue.showAll();
    System.out.println();
    queue.add(4);
    queue.showAll();
    System.out.println();
    queue.poll();
    queue.showAll();
    System.out.println();
    queue.add(5);
    queue.showAll();
}
```



