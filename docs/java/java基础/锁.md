# 锁
## 1. Sychronized 和 Lock
1. Sychronized：非公平，悲观，独享，互斥，可重入的重量级
2. Lock
 ReentrantLock：可公平，悲观，独享，互斥，可重入，重量级锁。
 ReentrantReadWriteLock：可公平，悲观，写独享，读共享，读写，可重入，重量级锁。

**Sychronized 和 ReentrantLock 的区别**

1. synchronized是关键字，Lock是Api
2. synchronized自动释放锁，Lock手动释放
3. synchronized不可以中断，ReentrantLock可中断(调用interrupt方法)
4. synchronized非公平锁，Lock两者皆可
5. synchronized只能随机或全部唤醒，Lock可以使用Condition精确唤醒

## 2. 锁分类
### 2.1 按性质分类
公平锁：多个线程按照申请锁的顺序来获取锁。
非公平锁：多个线程获取锁的顺序并不是按照申请锁的顺序。

乐观锁：采用尝试更新，不断重新的方式更新数据。
悲观锁：对于同一个数据的并发操作，悲观锁采取加锁的形式。

独享锁：该锁一次只能被一个线程所持有。
共享锁：该锁可被多个线程所持有。

互斥锁：写锁。
读写锁：读锁。

可重入锁：同一个线程在外层方法获取锁的时候，在进入内层加锁方法会自动获取锁。

### 2.2 按照设计分类
自旋锁：采用循环的方式去尝试获取锁。
自适应自旋锁：循环多次发现等待时间过长，切换为阻塞状态。

锁粗化：如一个方法内加了多个锁，JVM认为没必要，于是将其合并为一个锁。
锁消除：JVM认为有些代码块无需加锁，于是删除了那个锁。

偏向锁：一段同步代码一直被一个线程访问，该线程会自动获得锁。
轻量级锁：当锁是偏向锁的时候，被另外线程访问，其它线程会通过自旋的形式尝试获取锁。
重量级锁：当锁是轻量级锁的时候，另一个线程自旋到一定次数未得到锁则进入阻塞。

分段锁：将数据分为多段，每次只给一段加锁。


