(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{361:function(a,t,s){"use strict";s.r(t);var r=s(42),_=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"jvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),s("h2",{attrs:{id:"_1-类加载器-classloader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-类加载器-classloader"}},[a._v("#")]),a._v(" 1. 类加载器(ClassLoader)")]),a._v(" "),s("p",[s("strong",[a._v("类加载流程图：")]),a._v(" "),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200131191909464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),a._v(" "),s("strong",[a._v("类加载器示意图：")]),a._v(" "),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200131191931880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),a._v(" "),s("strong",[a._v("ClassLoader")]),a._v("：负责加载class文件（class文件在文件开头有特定文件标识）")]),a._v(" "),s("p",[s("strong",[a._v("各个类加载器的作用")])]),a._v(" "),s("p",[a._v("引导类加载器：加载JVM自身需要的类，使用C++实现，负责加载"),s("code",[a._v("%JAVA_HOME%/jre/lib.jar")]),a._v("核心类库。\n扩展类加载器：负责加载%JAVA_HOME%/lib/ext目录下的类。\n系统类加载器：负责加载系统类路径"),s("code",[a._v("java -classpath")]),a._v("或"),s("code",[a._v("-D java.class.path")]),a._v(" 指定路径下的类库。\n自定义类加载器：Java.lang.ClassLoader的子类")]),a._v(" "),s("p",[s("strong",[a._v("双亲委派")]),a._v("：当一个类收到了类加载请求，他首先不会自己去加载这个类，而是把这个请求委派给父类去完成，每一层请求类都是如此。只有当父类加载器反馈自己无法完成这个请求的时候，子类加载器才会尝试自己去加载。\n作用：沙箱安全，不让自己定义的类去勿扰JDK出厂自带的类")]),a._v(" "),s("h2",{attrs:{id:"_2-jvm内存模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-jvm内存模型"}},[a._v("#")]),a._v(" 2. JVM内存模型")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200131192106991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),a._v(" "),s("ol",[s("li",[s("p",[s("strong",[a._v("Java虚拟机栈")]),a._v("：存放 局部变量表、操作数栈、动态链接、方法出口")]),a._v(" "),s("p",[a._v("局部变量表：boolean、byte、char、short、int、float、long、double、reference")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("堆")]),a._v("：存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("方法区")]),a._v("：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据")]),a._v(" "),s("p",[a._v("运行时常量池：方法区的一部分，存放常量信息。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("程序计数器")]),a._v("：存放程序下一跳指令所在单元地址的地方。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("本地方法栈")]),a._v("：存放native方法的地方。")])])]),a._v(" "),s("h2",{attrs:{id:"_3-栈-stack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-栈-stack"}},[a._v("#")]),a._v(" 3. 栈（Stack）")]),a._v(" "),s("ol",[s("li",[a._v("栈的概述\n栈内存主管Java程序的运行，是在线程创建的时候创建，它的生命期是跟随线程的生命期，线程结束栈内存释放，生命周期和线程一致，是线程私有的。对于栈来说不存在垃圾回收问题。\n8种基本类型变量 、对象引用变量 、实例方法 都是在函数的栈内存中分配")]),a._v(" "),s("li",[a._v("Java方法 = 栈帧，主要保存3类数据\n"),s("ol",[s("li",[a._v("局部变量（Local Variables）：输入参数和输出参数及方法内的变量")]),a._v(" "),s("li",[a._v("栈操作（Operand Stack）：记录出栈、入栈的操作")]),a._v(" "),s("li",[a._v("栈帧数据（Frame Data）：包括类文件、方法等等")])])])]),a._v(" "),s("h2",{attrs:{id:"_4-堆-heap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-堆-heap"}},[a._v("#")]),a._v(" 4. 堆（Heap）")]),a._v(" "),s("p",[a._v("一个JVM实例只存在一个堆内存，堆内存大小是可以调节的。\n类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保证所有引用类型的真实信息，以方便执行器执行。\n堆内存逻辑上分为三部分：新生、养老、永久\n伊甸区满了，开启YGC（Young GC），Eden基本全部清空\n养老区满了，开启FGC（Full GC），若是FGC多次，发现养老区空间没法腾出来，就会报OOM（OutOfMemeryError）\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200131193503949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),a._v("\nYGC的过程：复制 -> 清空 -> 互换")]),a._v(" "),s("ol",[s("li",[a._v("eden、SurvivorFrom复制到SurvivorTo，年龄+1\n首先，当Eden区满的时候会触发第一次GC，把还活着的拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区，对这两个区域进行垃圾回收，经过这次回收后还存活着的对象直接复制到To区域（如果有对象的年龄已经达到了老年标准，则复制到老年代区），同时把这些对象年龄+1")]),a._v(" "),s("li",[a._v("清空eden、SurvivorFrom\n然后清空Eden和SurvivorFrom中的对象，也即复制后有交换，谁空谁是To")]),a._v(" "),s("li",[a._v("SurvivorFrom和SurvivorTo互换\n最后SurvivorFrom和SurvivorTo互换，原SurvivorTo成为下一次GC时SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数的MaxTenuringThreshold决定，这个参数默认是15），最终如果还存活，就存入老年代。")])]),a._v(" "),s("p",[a._v("经研究，不同对象的生命周期不同，98%的对象是临时对象。")]),a._v(" "),s("p",[a._v("实际而言，方法区和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的类信息、普通常量、静态常量、编辑器编译后的代码等等。虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名Non-Heap(非堆)，目的就是要和堆分开。永久代是方法区的一个实现。")]),a._v(" "),s("p",[a._v("永久区用于存放JDK自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所用的内存。\n内存调优参数")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("参数")]),a._v(" "),s("th",[a._v("说明")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[a._v("-Xms")]),a._v(" "),s("td",[a._v("设置初始值大小，默认为物理内存的 1/64")])]),a._v(" "),s("tr",[s("td",[a._v("-Xmx")]),a._v(" "),s("td",[a._v("最大分配内存，默认为物理内存的 1/4")])]),a._v(" "),s("tr",[s("td",[a._v("-XX:+PrintGCDetails")]),a._v(" "),s("td",[a._v("输出详细的GC处理日志")])])])]),a._v(" "),s("p",[a._v("Java8以后元空间并不在虚拟机中，而是使用本机物理内存。")]),a._v(" "),s("h2",{attrs:{id:"_5-栈、堆、方法区的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-栈、堆、方法区的关系"}},[a._v("#")]),a._v(" 5. 栈、堆、方法区的关系")]),a._v(" "),s("p",[a._v("栈管运行，堆管存储\nHotSpot是使用指针的方式来访问对象\nJava堆中会存放访问类元数据的地址\nreference存储的就直接是对象的地址\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200114211523636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),a._v("\n代码解释：左边存在栈中。右边存在堆中")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Person")]),a._v(" person "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Person")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"张三"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("h2",{attrs:{id:"_6-gc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-gc"}},[a._v("#")]),a._v(" 6. GC")]),a._v(" "),s("h3",{attrs:{id:"_6-1-gc概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-gc概述"}},[a._v("#")]),a._v(" 6.1 GC概述")]),a._v(" "),s("p",[a._v("GC是什么（分代收集算法）")]),a._v(" "),s("ul",[s("li",[a._v("频繁收集Young区")]),a._v(" "),s("li",[a._v("较少收集Old区")]),a._v(" "),s("li",[a._v("基本不动元空间")])]),a._v(" "),s("p",[a._v("普通GC(Minor GC):只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大部分Java对象存活率不高，所以Minor GC非常频繁，一般回收速度也比较快。\n全局GC(Major GC / Full GC)：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC，"),s("strong",[a._v("Major GC的速度一般要比Minor GC慢10倍以上")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"_6-2-gc四大算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-gc四大算法"}},[a._v("#")]),a._v(" 6.2 GC四大算法")]),a._v(" "),s("ol",[s("li",[a._v("引用计数法（JVM一般不采用这种方式）\n没有被引用的内存空间就是垃圾，需要被收集\n缺点：计数器本身有消耗，较难处理循环引用")]),a._v(" "),s("li",[a._v("复制算法（Copying）\nYGC用的是复制算法，复制算法的基本思想是将内存分为两块，每次只用其中一块，当一块内存用完，就将还活着的对象复制到另一块上面，复制算法不会产生内存碎片。\n原理：从根集合（GC Root）开始，通过Tracing从From中找到存活对象，拷贝到To中。From和To交换身份，下次内存分配从To开始\n缺点：浪费了一半内存")]),a._v(" "),s("li",[a._v("标记清除（Mark-Sweep）\n老年代一般由标记清除和标记整理混合实现\n原理：算法分成标记和清除两个阶段。先标记出要回收的对象，然后统一回收这些对象。\n解释：程序运行期间，可用内存将被耗尽的时候,GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象。\n缺点：两次扫描，耗时严重，会产生内存碎片（清理出来的内存是不连续的）")]),a._v(" "),s("li",[a._v("标记压缩（Mark-Compact）\n即标记清除整理\n第一步：标记清除\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200117210457686.png",alt:"在这里插入图片描述"}}),a._v("\n第二步：压缩\n再次扫描，并往一端滑动存活对象\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200117210521309.png",alt:"在这里插入图片描述"}}),a._v("\n优势：没有碎片\n劣势：需要移动对象的成本")])]),a._v(" "),s("h3",{attrs:{id:"_6-3-gc-root"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-gc-root"}},[a._v("#")]),a._v(" 6.3 GC Root")]),a._v(" "),s("p",[a._v("可达性分析算法：通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。")]),a._v(" "),s("p",[s("strong",[a._v("Java 可以做GC Root的对象")]),a._v("：局部变量表、类静态属性引用的对象、常量引用的对象、Native方法引用的对象。")]),a._v(" "),s("h3",{attrs:{id:"_6-4-垃圾收集器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-垃圾收集器"}},[a._v("#")]),a._v(" 6.4 垃圾收集器")]),a._v(" "),s("ul",[s("li",[a._v("Serial(串行回收) : 单线程，会暂停所有的用户线程")]),a._v(" "),s("li",[a._v("Parallel(并行回收) : 多线程，会暂停所有的用户线程")]),a._v(" "),s("li",[a._v("CMS(并发标记清除) : 用户线程和垃圾收集线程同时执行(并行或交替)，会产生碎片")]),a._v(" "),s("li",[a._v("G1: 将堆内存分割成不同的区域并发的对其进行垃圾回收")])]),a._v(" "),s("p",[s("strong",[a._v("查看当前使用的垃圾回收器")])]),a._v(" "),s("div",{staticClass:"language-powershell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-powershell"}},[s("code",[a._v("java "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX:"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v("PrintCommandLineFlags "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("version\n")])])]),s("h3",{attrs:{id:"_6-5-引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-引用"}},[a._v("#")]),a._v(" 6.5 引用")]),a._v(" "),s("ul",[s("li",[a._v("强引用：OOM也不回收")]),a._v(" "),s("li",[a._v("软引用：内存不足时回收")]),a._v(" "),s("li",[a._v("弱引用：只要执行GC就被回收")]),a._v(" "),s("li",[a._v("虚引用：跟没引用一样，作用是在对象回收前做操作")])])])}),[],!1,null,null,null);t.default=_.exports}}]);