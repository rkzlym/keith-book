(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{365:function(t,n,_){"use strict";_.r(n);var r=_(42),e=Object(r.a)({},(function(){var t=this,n=t.$createElement,_=t._self._c||n;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),_("h2",{attrs:{id:"_1-sychronized-和-lock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-sychronized-和-lock"}},[t._v("#")]),t._v(" 1. Sychronized 和 Lock")]),t._v(" "),_("ol",[_("li",[t._v("Sychronized：非公平，悲观，独享，互斥，可重入的重量级")]),t._v(" "),_("li",[t._v("Lock\nReentrantLock：可公平，悲观，独享，互斥，可重入，重量级锁。\nReentrantReadWriteLock：可公平，悲观，写独享，读共享，读写，可重入，重量级锁。")])]),t._v(" "),_("p",[_("strong",[t._v("Sychronized 和 ReentrantLock 的区别")])]),t._v(" "),_("ol",[_("li",[t._v("synchronized是关键字，Lock是Api")]),t._v(" "),_("li",[t._v("synchronized自动释放锁，Lock手动释放")]),t._v(" "),_("li",[t._v("synchronized不可以中断，ReentrantLock可中断(调用interrupt方法)")]),t._v(" "),_("li",[t._v("synchronized非公平锁，Lock两者皆可")]),t._v(" "),_("li",[t._v("synchronized只能随机或全部唤醒，Lock可以使用Condition精确唤醒")])]),t._v(" "),_("h2",{attrs:{id:"_2-锁分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-锁分类"}},[t._v("#")]),t._v(" 2. 锁分类")]),t._v(" "),_("h3",{attrs:{id:"_2-1-按性质分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-按性质分类"}},[t._v("#")]),t._v(" 2.1 按性质分类")]),t._v(" "),_("p",[t._v("公平锁：多个线程按照申请锁的顺序来获取锁。\n非公平锁：多个线程获取锁的顺序并不是按照申请锁的顺序。")]),t._v(" "),_("p",[t._v("乐观锁：采用尝试更新，不断重新的方式更新数据。\n悲观锁：对于同一个数据的并发操作，悲观锁采取加锁的形式。")]),t._v(" "),_("p",[t._v("独享锁：该锁一次只能被一个线程所持有。\n共享锁：该锁可被多个线程所持有。")]),t._v(" "),_("p",[t._v("互斥锁：写锁。\n读写锁：读锁。")]),t._v(" "),_("p",[t._v("可重入锁：同一个线程在外层方法获取锁的时候，在进入内层加锁方法会自动获取锁。")]),t._v(" "),_("h3",{attrs:{id:"_2-2-按照设计分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-按照设计分类"}},[t._v("#")]),t._v(" 2.2 按照设计分类")]),t._v(" "),_("p",[t._v("自旋锁：采用循环的方式去尝试获取锁。\n自适应自旋锁：循环多次发现等待时间过长，切换为阻塞状态。")]),t._v(" "),_("p",[t._v("锁粗化：如一个方法内加了多个锁，JVM认为没必要，于是将其合并为一个锁。\n锁消除：JVM认为有些代码块无需加锁，于是删除了那个锁。")]),t._v(" "),_("p",[t._v("偏向锁：一段同步代码一直被一个线程访问，该线程会自动获得锁。\n轻量级锁：当锁是偏向锁的时候，被另外线程访问，其它线程会通过自旋的形式尝试获取锁。\n重量级锁：当锁是轻量级锁的时候，另一个线程自旋到一定次数未得到锁则进入阻塞。")]),t._v(" "),_("p",[t._v("分段锁：将数据分为多段，每次只给一段加锁。")])])}),[],!1,null,null,null);n.default=e.exports}}]);