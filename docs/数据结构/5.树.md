# 树

## 二叉树

**二叉树的遍历方式**

前序遍历：先访问根节点，再遍历左子树，最后遍历右子树。时间复杂度 O(n)

```java
void preOrder(Node n){
    if (n != null){
        visit(n);
        preOrder(n.left);
        preOrder(n.right)
    }
}
```

中序遍历：先遍历左子树，再访问根节点，最后遍历右子树。

```java
void InOrder(Node n){
    if (n != null){
        InOrder(n.left);
        visit(n);
        InOrder(n.right)
    }
}
```

后序遍历：从左到后从叶子节点遍历左右子树，最后访问根节点。

```java
void postOrder(Node n){
    if (n != null){
        postOrder(n.left);
        postOrder(n.right)
        visit(n);
    }
}
```

层次遍历：从根节点一层一层的从左到右遍历整个二叉树树

算法思想：

1. 初始将根入队并访问根节点
2. 若有左子树，则将左子树的根入队
3. 若有右子树，则将右子树的根入队
4. 然后出队，访问该节点
5. 反复这个过程直到队列空为止

```java
void levelOrder(BiTreeNode t) {
	if (t == null)
		return;
	Queue<BiTreeNode> queue = new LinkedBlockingQueue<>();
	BiTreeNode curr;
	queue.add(t);
	while (!queue.isEmpty()) {
		curr = queue.remove();
		System.out.println(curr.value);
		if (curr.left != null)
			queue.add(curr.left);
		if (curr.right != null)
			queue.add(curr.right);
	}
}
```

**中序遍历转换为非递归算法**

1. 初始时依次扫描根节点的所有左侧节点并将它们一一进栈
2. 出栈一个节点，访问它
3. 扫描该节点的右孩子节点并将其进栈
4. 依次扫描右孩子节点的所有左侧节点并一一进栈
5. 反复该过程直到栈空为止

```java
void InOrder(Node n){
    Node p = n;
    while(!stack.isEmpty()){
        if (p != null){
            stack.push(p);
            p = p.left;
        } else {
            visit(stack.pop());
       		p = p.right;
        }
    }
}
```

**使用遍历构造二叉树**

先序 / 后序遍历序列 + 中序遍历序列可以确定一棵二叉树

先序遍历序列 + 后序遍历序列<font color=blue>不能</font>确定一棵二叉树

原因：中序遍历序列可以确定左右子树，先序 / 后序 遍历序列可以确定根节点

1. 在先序序列中，第一个节点是根节点
2. 根节点将中序遍历序列划分为两部分
3. 然后在先序序列中确定两部分的节点，并且两部分的第一个节点分别为左子树的根和右子树的根
4. 在子树中重复递归该过程，便能唯一确定一棵二叉树

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210204231919982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)