# 亿级流量多级缓存

## 第一级缓存：DNS域名解析

客户端访问一个域名的时候，会去DNS服务器上获取域名对应的IP并缓存到本地，一个域名可以对应多个IP

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113220847835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

## 第二级缓存：Nginx缓存

### Nginx全局共享内存缓存

> 使用 lua 访问 nginx 的内存，线程越多，性能损耗越大
>
> 不是特别高并发的情况下可以用 shared_dict

```nginx
lua_shared_dict shared_data 1m;
```

```lua
local shared_data = ngx.shared.shared_data  

local i = shared_data:get("i")  
if not i then  
    i = 1  
    shared_data:set("i", i)  
    ngx.say("lazy set i ", i, "<br/>")  
end  
i = shared_data:incr("i", 1)  
ngx.say("i=", i, "<br/>")
```

### lua-resty-lrucache

Lua 实现的一个简单的 LRU 缓存，适合在 Lua 空间里直接缓存较为复杂的 Lua 数据结构：

它相比 ngx_lua 共享内存字典可以省去较昂贵的序列化操作，相比 memcached 这样的外部服务又能省去较昂贵的 socket 操作

lrucache 有两种实现

- resty.lrucache
  - 适合用来缓存命中率高或读操作远远大于写操作的缓存业务
- resty.lrucache.pureffi
  - 适合用来缓存命中率低或需要对key进行频繁增、删操作的缓存业务

```lua
local lrucache = require "resty.lrucache"
local c, err = lrucache.new(200)
	c:set("dog", 32)
    c:set("cat", 56)
    ngx.say("dog: ", c:get("dog"))
    ngx.say("cat: ", c:get("cat"))

    c:set("dog", { age = 10 }, 0.1)  -- expire in 0.1 sec
    c:delete("dog")

```

https://github.com/openresty/lua-resty-lrucache#name