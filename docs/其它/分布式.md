# 分布式

## 相关术语

qps：每秒的请求数 （Nginx：5w qps，Tomcat：200 qps）

集群：镜像

分布式：服务模块化拆分

SOA：面向服务架构

## 对比网络传输格式

XML：文件大，性能低，结构严谨，可使用XSD校验

JSON：文件小，性能高，结构不严谨，可读性差

序列化：最小（二进制数据），性能最高，面向对象，无可读性

## 接口如何处理重复请求

**单机**：打开页面时先将一个唯一编号保存在session域中，提交表单时判断session域中的数据是否一致。

**分布式**：生成一个全局唯一ID，插入redis中，每次请求先进redis判断

## 分布式Session

Tomcat + redis：在Tomcat配置文件中配置一下redis session

Spring Session + redis

## 分布式锁

**数据库实现**：使用一张锁表(id, lock_name)，其中lock_name唯一

每次执行业务前先查锁表中是否有这个lock_name，如有则失败，没有则插入锁表并执行业务，并删除锁。

**redis实现**：利用setnx的返回值特性，有值返回失败，无值返回成功。

redisson：一种基于redis的封装好的分布式锁。

**zookeeper实现**：有序临时节点 + watch监听

为每一个执行的线程创建一个有序的临时节点，为了确保有序性，在创建完节点，会再获取全部节点，会再获取全部节点，再重新进行一次排序，排序过程中，每个线程要判断自己的节点的序号是否是最小的。

如果是最小的，将会获取到锁，执行相关操作，释放锁

如果不是最小的，会监听到它的前一个节点，当它前一个节点被删除时，它就会获取锁，一次类推

## 分布式事务

### 两阶段提交方案 / XA

常见场景：操作多个数据库，并需要满足事务。

阶段1：事务管理器询问每一个服务是否可以提交，任何一个服务拒绝，事务管理器全部回滚。

阶段2：每个服务都响应可以后执行。

**实现方式**：Spring + JTA

**说明**：规范是每个服务只能操作自己的数据库，如果要操作别的数据库，不允许直连，否则无法治理。

如果A系统可以访问B系统数据库，那么就会出现数据乱套现象。

如果A系统需要访问B系统数据库，可以通过调用服务接口实现。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210106220851600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

### TCC

1. Try：事务询问，对各个服务的资源做检测以及对资源进行锁定或者预留。

2. Confirm：在各个服务中执行实际的操作。

3. Cancel：如果任一服务的业务方法执行出错，就需要进行补偿，即把那些执行成功的回滚。

**使用场景**：对分布式事务一致性要求高，如跟钱相关的。

**缺点**：重耦合，需要手写补偿逻辑。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210106221025144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

### 本地消息表方案

1. A系统先插入数据到业务表，再插入消息表，再插入到MQ。

2. B系统接收到消息，先插入数据到消息表，再插入业务表，如果消息已被处理就回滚，防止重复消费。
3. B系统执行成功后，更新本地消息表以及 A 系统消息表的状态。
4. B系统执行失败，就不会更新，A系统会定时扫描本地消息表，如果有未处理消息，会再次发送到MQ。

**缺陷**：严重依赖于数据库的消息表来管理事务，高并发场景性能太差。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210106220851600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

### 可靠消息最终一致性方案

1. A 系统先发送一个 prepared 消息到 MQ，如果 prepared 消息发送失败则取消执行。
2. 如果perpared消息发送成功，执行本地事务，成功则给 mq 发送确认消息，失败则给 mq发送回滚消息。
3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
4. RocketMq 定时轮询所有 prepared 消息回调A系统接口，回滚或重发。
5. B系统失败通知Zookeeper，Zookeeper通知A系统回滚。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210106221157460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

### 最大努力通知方案

1. A系统本地事务执行完之后，发送个消息到 MQ。
2. 最大努力通知服务会消费 MQ 然后写入数据库中记录下来，再调用B系统的接口。
3. 若系统 B 执行失败，最大努力通知服务会定时尝试重新调用B系统，反复N次，最后还是不行就放弃。

**说明**：可以在一定程度上允许少数分布式事务失败，一般用于对事务要求不严格场景。

![image-20210106221240541](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20210106221240541.png)

## Dubbo

**RPC协议**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210106221257207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

| 协议名称   | 实现描述                                     | 连接                                     | 使用场景                                                     |
| ---------- | -------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| dubbo      | netty                                        | 单一长连接和NIO异步传输                  | 小数据量大并发的服务调用，消费者比提供者多，不适合传送大数据量的服务，比如文件、传视频 |
| rmi        | 采用JRM 作为通讯协议                         | 多连接，短连接，TCP/IP，BIO              | 可传文件，不支持防火墙穿透                                   |
| hessian    | hessian二进制序列化                          | 多连接，短连接，传输协议：HTTP，同步传输 | 提供者比消费者多 ，可传文件，跨语言传输                      |
| http       | 表单序列化                                   | 多连接，短连接，HTTP，同步传输           | 提供者大于消费者，数据包混合                                 |
| webservice | SOAP文件序列化                               | 多连接，短连接，HTTP，同步传输           | 系统集成，跨语言调用                                         |
| thrift     | 与thrift RPC实现集成，并在基础上修改了报文头 | 长连接、NIO异步传输                      |                                                              |

## Zookeeper

概念：一致有头数据树，解决分布式系统数据一致性问题。

**三种角色**

Leader：负责处理集群的写请求，并发起投票，只有超过半数的节点同意后才会提交该请求。

Follower：处理读请求，相应结果，转发写请求给leader，在选举leader时参与投票。

Observer：没有投票权的follower，协助follower处理读请求。

**应用场景**：配置中心、负载均衡、命名服务、DNS服务、集群管理

**zookeeper缺陷**：master宕机后剩余节点会重新进行leader选举，但选举时间太长（30-120s），且选举期间整个集群都是不可用的，这就导致了在选举期间注册服务瘫痪。

