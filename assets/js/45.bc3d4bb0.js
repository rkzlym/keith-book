(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{399:function(_,t,v){"use strict";v.r(t);var a=v(42),s=Object(a.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"rabbitmq应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq应用"}},[_._v("#")]),_._v(" RabbitMQ应用")]),_._v(" "),v("h2",{attrs:{id:"消息堆积"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息堆积"}},[_._v("#")]),_._v(" 消息堆积")]),_._v(" "),v("p",[_._v("当生产者生产的速度长时间远远大于消费的速度时，就会造成消息堆积。")]),_._v(" "),v("ul",[v("li",[_._v("消息堆积的影响\n"),v("ul",[v("li",[_._v("可能导致新消息无法进入队列")]),_._v(" "),v("li",[_._v("可以导致旧消息无法丢失")]),_._v(" "),v("li",[_._v("消息等待的消费时间过长，超出了业务容忍范围")])])]),_._v(" "),v("li",[_._v("产生堆积的情况\n"),v("ul",[v("li",[_._v("生产者突然大量发布消息")]),_._v(" "),v("li",[_._v("消费者消费失败")]),_._v(" "),v("li",[_._v("消费者出现性能瓶颈")])])]),_._v(" "),v("li",[_._v("解决办法\n"),v("ul",[v("li",[_._v("排查消费者的性能瓶颈")]),_._v(" "),v("li",[_._v("增加消费者的多线程处理")]),_._v(" "),v("li",[_._v("部署多个消费者")])])])]),_._v(" "),v("p",[v("strong",[_._v("消息已经堆积如何解决")])]),_._v(" "),v("p",[_._v("消息队列堆积，想办法把消息转移到一个新的队列，增加服务器来慢慢消费。")]),_._v(" "),v("h2",{attrs:{id:"消息丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息丢失"}},[_._v("#")]),_._v(" 消息丢失")]),_._v(" "),v("p",[_._v("消息生产者发送消息成功，但是MQ没有收到消息，消息在从生产者传输到MQ的过程中丢失，一般是由于网络不稳定等原因。")]),_._v(" "),v("p",[v("strong",[_._v("解决方案")])]),_._v(" "),v("ol",[v("li",[v("p",[_._v("采用RabbitMQ的消息确认机制，当消息成功被MQ接收到时，会给生产者发送一个确认消息表示接收成功。")]),_._v(" "),v("p",[_._v("RabbitMQ发送方消息确认模式有三种：普通确认模式，批量确认模式，异步监听确认模式。")]),_._v(" "),v("p",[_._v("异步监听确认模式：边发送消息边进行确认，不影响主线程任务进行。")])]),_._v(" "),v("li",[v("p",[_._v("RabbitMQ持久化交换机、队列、消息，确保MQ服务重启时能从磁盘恢复对应的交换机、队列和消息。")]),_._v(" "),v("p",[_._v("Spring整合后默认开启了交换机、队列、消息的持久化。")])])]),_._v(" "),v("h2",{attrs:{id:"有序消费"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有序消费"}},[_._v("#")]),_._v(" 有序消费")]),_._v(" "),v("p",[v("strong",[_._v("场景1")])]),_._v(" "),v("p",[_._v("当RabbitMQ采用Work Queue模式，此时只会有一个Queue但是会有多个Consumer，同时多个Consumer直接是竞争关系，此时就会出现MQ消息乱序的问题。")]),_._v(" "),v("p",[_._v("解决方案：生产者根据 ID 计算出一个 Hash 值，然后对队列的个数取余，可以让相同 ID 的所有操作压到同一个队列，且每个队列都只有一个消费者，此时就不会出现乱序的情况。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210126162412781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[v("strong",[_._v("场景2")])]),_._v(" "),v("p",[_._v("当RabbitMQ采用简单队列模式的时候，如果消费者采用多线程处理消息，会出现消息乱序的问题。")]),_._v(" "),v("p",[_._v("解决方案：消费者拉取消息然后根据 ID 算出一个 Hash 然后把相同 ID 的数据压到同一个内存队列，让同一个线程去处理，保证有序。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210126162801750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),v("h2",{attrs:{id:"重复消费"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重复消费"}},[_._v("#")]),_._v(" 重复消费")]),_._v(" "),v("p",[_._v("为了防止消息在消费端丢失，会采用手动确认MQ的方式来解决，但是会引出一个问题，消费者处理消息成功，回复MQ时由于网络不稳定等因素未成功，MQ认为消费者消费失败，会通过消息的重发导致重复消费。")]),_._v(" "),v("p",[_._v("解决方案")]),_._v(" "),v("p",[_._v("使用redis的setnx命令存储消息id，每次消费前先查询该消息id是否存在，如果存在证明已经消费过则不再进行消费。")]),_._v(" "),v("blockquote",[v("p",[_._v("setnx(key,value)\t如果key不存在则插入成功且返回1，如果key存在则不操作且返回0")])])])}),[],!1,null,null,null);t.default=s.exports}}]);