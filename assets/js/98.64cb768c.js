(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{451:function(t,e,a){"use strict";a.r(e);var r=a(42),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),a("h2",{attrs:{id:"redis实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis实现"}},[t._v("#")]),t._v(" redis实现")]),t._v(" "),a("p",[t._v("利用setnx的返回值特性，有值返回失败，无值返回成功。")]),t._v(" "),a("p",[t._v("redisson：一种基于redis的封装好的分布式锁。")]),t._v(" "),a("h2",{attrs:{id:"数据库实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库实现"}},[t._v("#")]),t._v(" 数据库实现")]),t._v(" "),a("p",[t._v("使用一张锁表(id, lock_name)，其中lock_name唯一")]),t._v(" "),a("p",[t._v("每次执行业务前先查锁表中是否有这个lock_name，如有则失败，没有则插入锁表并执行业务，并删除锁。")]),t._v(" "),a("h2",{attrs:{id:"zookeeper实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper实现"}},[t._v("#")]),t._v(" zookeeper实现")]),t._v(" "),a("p",[t._v("有序临时节点 + watch监听")]),t._v(" "),a("p",[t._v("为每一个执行的线程创建一个有序的临时节点，为了确保有序性，在创建完节点，会再获取全部节点，会再获取全部节点，再重新进行一次排序，排序过程中，每个线程要判断自己的节点的序号是否是最小的。")]),t._v(" "),a("p",[t._v("如果是最小的，将会获取到锁，执行相关操作，释放锁")]),t._v(" "),a("p",[t._v("如果不是最小的，会监听到它的前一个节点，当它前一个节点被删除时，它就会获取锁，一次类推")])])}),[],!1,null,null,null);e.default=s.exports}}]);