(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{415:function(v,_,t){"use strict";t.r(_);var e=t(42),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"redis常见缓存问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis常见缓存问题"}},[v._v("#")]),v._v(" redis常见缓存问题")]),v._v(" "),t("p",[t("strong",[v._v("缓存与数据库双写不一致")])]),v._v(" "),t("p",[v._v("现象1：先修改数据库，再删除缓存，如果缓存删除失败，缓存中是旧数据，就会出现数据不一致。")]),v._v(" "),t("p",[v._v("解决1：先删除缓存，再修改数据库，如果修改数据库失败了，数据库是旧数据，缓存为空，数据一致。")]),v._v(" "),t("p",[v._v("现象2：在更新一个库存的时候，同时在读取这个库存，此时数据库修改还未完成，旧的数据就会落到缓存中。")]),v._v(" "),t("p",[v._v("解决2：将数据库与缓存的更新和读取进行异步串行化。")]),v._v(" "),t("p",[t("strong",[v._v("缓存雪崩")])]),v._v(" "),t("p",[v._v("现象：key集中过期导致短时间内大量请求落到数据库。")]),v._v(" "),t("p",[v._v("解决方案：过期时间使用固定时间+随机值模式，稀释集中到期的key的数量")]),v._v(" "),t("p",[t("strong",[v._v("缓存穿透")])]),v._v(" "),t("p",[v._v("现象：查询一个一定不存在的数据，缓存不会命中")]),v._v(" "),t("p",[v._v("解决：空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。")]),v._v(" "),t("p",[t("strong",[v._v("缓存击穿")])]),v._v(" "),t("p",[v._v("现象：超高热点的key过期导致短时间内大量请求落到数据库。")]),v._v(" "),t("p",[v._v("解决：分布式锁")]),v._v(" "),t("p",[t("strong",[v._v("缓存内存超出设置的最大值会发生什么")])]),v._v(" "),t("p",[v._v("OOM command not allowed when used memory")])])}),[],!1,null,null,null);_.default=s.exports}}]);